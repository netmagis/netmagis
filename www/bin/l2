#!%TCLSH%

#
# Script pour lister les vlans, ou les détails d'un vlan
#
# Appelé par : /applis/topo/<tous>
#
# Paramètres (formulaire ou URL) :
#	- eq : nom de l'équipement
#	- iface : nom d'une interface à souligner
#	- vlan : numéro d'un vlan sur l'interface, ou partie de description
#	- format : rien, ou "pdf" ou "png"
#
# Historique
#   2006/06/05 : pda      : création
#   2006/06/20 : pda      : prologue dépendant du format
#   2006/06/22 : pda      : correction d'un bug sur les numéros de liens
#   2006/06/22 : pda      : sortie dépendante du format
#   2006/08/09 : pda      : ps2pdf avec chemin complet
#   2006/08/14 : pda      : fusion avec listl2
#   2007/01/04 : pda      : ajout du paramètre uti
#

set conf(homeurl)	%HOMEURL%

#
# Chemins utilisés par les scripts
#

set conf(pkg)		%PKGTCL%
set conf(lib)		%DESTDIR%/lib
set conf(libdns)	%LIBDNS%
set conf(libmetro)	$conf(lib)/libtopo.tcl

#
# Définition des noms des pages "à trous"
#

set conf(err)		$conf(lib)/erreur.html
set conf(page1)		$conf(lib)/l2.html
set conf(pagen)		$conf(lib)/liste.html

#
# Quelques paramètres du script
#

set conf(auth)		%AUTH%
set conf(base)		%BASE%
set conf(nologin)	%NOLOGIN%

set conf(form)	{
    {uti		0 1}
    {eq			0 1}
    {iface		0 1}
    {vlan		0 1}
    {format		0 1}
}

set conf(extractl2)	"%TOPODIR%/bin/extractl2 %s %s %d < %GRAPH%"
set conf(urleq)		"$conf(homeurl)/bin/eq?eq=%s"
set conf(urleqiface)	"$conf(homeurl)/bin/eq?eq=%s&iface=%s"
set conf(urll2)		"$conf(homeurl)/bin/l2?vlan=%s"
set conf(urll3)		"$conf(homeurl)/bin/l3?addr=%s"
set conf(dot)		"%DOT%"
set conf(neato)		"%NEATO%"
set conf(ps2pdf)	"%PS2PDF%"

set conf(maxdot)	12


#
# Les outils du parfait concepteur de pages Web dynamiques...
#

lappend auto_path $conf(pkg)
package require auth
package require webapp
package require pgsql

#
# On y va !
#

# ::webapp::cgidebug ; exit

source $conf(libdns)
source $conf(libmetro)

##############################################################################
# Fonctions utilitaires
##############################################################################

proc match-eq {type_model} {
    switch -glob -- $type_model {
	juniper/M* {
	    set attr {shape=circle
				style=filled fillcolor=lightgrey
				fixedsize height=1}
	}
	cisco/WS-C45* {
	    set attr {shape=box style=filled fillcolor=lightblue}
	}
	cisco/WS-C37* -
	cisco/WS-C29* {
	    set attr {shape=box style=filled fillcolor=lightblue height=.25}
	}
	cisco/WS-*PS  {
	    set attr {shape=box style=filled fillcolor=yellow height=.25}
	}
	cisco/37*  {
	    set attr {shape=octagon style=filled fillcolor=orange1 height=.25}
	}
	cisco/38*  {
	    set attr {shape=octagon style=filled fillcolor=orange1}
	}
	alcatel/switch {
	    set attr {shape=box height=.35}
	}
	nuage/* {
	    set attr {shape=ellipse style=filled fillcolor=palegreen width=1.5}
	}
	fwroute* {
	    set attr {shape=circle
				style=filled fillcolor=tomato
				height=1}
	}
	fw* {
	    set attr {shape=box style=filled fillcolor=tomato height=.25}
	}
	switch* {
	    set attr {shape=box style=filled fillcolor=lightgrey height=.25}
	}
	default {
	    set attr {shape=triangle}
	}
    }
    return $attr
}

proc conv-ifname {ifname} {
    foreach p {
		{ GigabitEthernet Gi}
		{ FastEthernet Fa}
		{ Port-channel Po}
		{ (ge-.*)/0$ \\1}
		} {
	set pattern [lindex $p 0]
	set subst   [lindex $p 1]
	regsub -all $pattern $ifname $subst ifname
    }
    return $ifname
}

proc prologue {format} {
    set g "graph l2graph \{"
    switch $format {
	pdf {
	    append g {
		fontsize = 14 ;
		fontname = "Helvetica" ;
		margin = .3 ;
		center = true ;
		page="8.26,11.69" ;

		size="11,7.6" ;
		orientation = landscape ;

		/* len = 0.5 ; */
		/* ranksep = 0.5 */
		fontname = Helvetica ;

		node [fontname = Helvetica, fontsize = 10,
			    color = grey
			] ;
		edge [fontname = Helvetica, fontsize = 8,
			    len = 1.4,
			    labelfontname = Helvetica, labelfontsize = 6,
			    color = grey
			] ;

		overlap = false ;
		spline = true ;
	    }
	}
	png -
	default {
	    append g {
		    fontsize = 14 ;
		    fontname = "Helvetica" ;
		    margin = .3 ;
		    center = true ;

		    orientation = portrait ;

		    /* len = 0.5 ; */
		    /* ranksep = 0.5 */
		    fontname = Helvetica ;

		    node [fontname = Helvetica, fontsize = 10,
				color = grey
			    ] ;
		    edge [fontname = Helvetica, fontsize = 8,
				len = 1.4,
				labelfontname = Helvetica, labelfontsize = 6,
				color = grey
			    ] ;

		    overlap = false ;
		    spline = true ;
		}
	}
    }
    return "$g\n"
}

proc title {vlanlist} {
    set vlan0 0
    set vl ""
    foreach v $vlanlist {
	set vlanid   [lindex $v 0]
	set vlandesc [lreplace $v 0 0]
	switch -- $vlanid {
	    0 {
		set vlan0 1
	    }
	    1 {
		# rien
	    }
	    default {
		if {! [string equal $vl ""]} then {
		    append vl "\\n"
		}
		append vl "Vlan $vlanid : $vlandesc"
	    }
	}
    }
    if {[string equal $vl ""] && $vlan0} then {
	set vl "Vlan 0"
    }
    return "label = \"$vl\" ;\n"
}

proc epilogue {format} {
    return "\}\n"
}


proc generer-dot {format eq iface vlan prog urlfmt _nnodes} {
    upvar $_nnodes nnodes

    set nnodes 0
    set fd [open "|$prog" "r"]
    while {[gets $fd ligne] > -1} {
	switch [lindex $ligne 0] {
	    vlans {
		set vlans [lreplace $ligne 0 0]
	    }
	    eq {
		set nomeq      [lindex $ligne 1]
		set typemodele [lindex $ligne 2]
		set tabeq($nomeq) $typemodele
		incr nnodes
	    }
	    link {
		set linkname [lindex $ligne 1]
		set eq1      [lindex $ligne 2]
		set iface1   [lindex $ligne 3]
		set eq2      [lindex $ligne 4]
		set iface2   [lindex $ligne 5]
		set tablink($linkname) [list $eq1 $iface1 $eq2 $iface2]
	    }
	}
    }
    if {[catch {close $fd}]} then {
	return ""
    }

    #
    # Mettre en forme toutes ces informations
    #

    set dot [prologue $format]
    append dot [title $vlans]

    foreach nomeq [array names tabeq] {
	set attrlist [match-eq $tabeq($nomeq)]

	set url [format $urlfmt $nomeq]
	lappend attrlist "href=\"$url\""

	set attr [join $attrlist ", "]
	append dot "\"$nomeq\" \[$attr\] ;\n"
    }

    foreach link [array names tablink] {
	set eq1 [lindex $tablink($link) 0]
	set if1 [conv-ifname [lindex $tablink($link) 1]]
	set eq2 [lindex $tablink($link) 2]
	set if2 [conv-ifname [lindex $tablink($link) 3]]

	set attrlist [list label=\"$link\" \
				headlabel=\"$if2\" \
				taillabel=\"$if1\" \
			    ]
	set attr [join $attrlist ", "]
	append dot "\"$eq1\" -- \"$eq2\" \[$attr\] ;\n"
    }

    append dot [epilogue $format]

    return $dot
}

proc chercher-vlans {vlan _tabvlan} {
    upvar $_tabvlan tabvlan

    set r {}
    if {[string equal $vlan ""]} then {
	#
	# Par défaut : liste de tous les vlans
	#
	set r [lsort -integer [array names tabvlan]]

    } elseif {[catch {expr $vlan+0}]} then {
	#
	# Pas un entier : il faut donc chercher le texte dans les
	# descriptions
	#
	set pattern "*${vlan}*"
	foreach v [lsort -integer [array names tabvlan]] {
	    if {[string match -nocase $pattern $tabvlan($v)]} then {
		lappend r $v
	    }
	}

    } else {
	lappend r $vlan

    }
    return $r
}

##############################################################################
# Programme principal
##############################################################################

proc main {} {
    global conf

    #
    # Initialisation
    #

    init-dns $conf(nologin) $conf(auth) $conf(base) $conf(err) "" \
			$conf(form) ftab dbfd login tabcor

    set tmp /tmp/l2-[pid]

    #
    # Récupération des paramètres dans des variables simples
    #

    foreach spec $conf(form) {
	set champ [lindex $spec 0]
	if {[info exists ftab($champ)]} then {
	    set $champ [string trim [lindex $ftab($champ) 0]]
	} else {
	    set $champ ""
	}
    }

    #
    # Si l'utilisateur est un administrateur, l'autoriser à se substituer
    # à un autre utilisateur.
    #

    set uti $login
    set urluti ""
    if {[attribut-correspondant $dbfd $tabcor(idcor) admin]} then {
	#
	# A partir de maintenant, on prend le nouveau login qui est
	# fourni dans le formulaire (s'il est fourni)
	#

	if {[llength $ftab(uti)] > 0} then {
	    set uti [lindex $ftab(uti) 0]
	    set urluti "&uti=[::webapp::post-string $uti]"
	    unset tabcor
	    set msg [lire-correspondant-par-login $dbfd $uti tabcor]
	    if {! [string equal $msg ""]} then {
		::webapp::error-exit $conf(err) "'$uti' non trouvé ($msg)"
	    }
	}
    }

    #
    # Récupération des descriptions de vlans
    #

    set msg [lire-vlans tabvlan]
    if {! [string equal $msg ""]} then {
	::webapp::error-exit $conf(err) "Lecture des vlans impossible ($msg)"
    }

    #
    # Valider les paramètres :
    # - tester si le correspondant a le droit sur l'équipement
    #


    #
    # Chercher la liste des vlans demandés
    #

    set lvlans [chercher-vlans $vlan tabvlan]

    set qvlan [::webapp::html-string $vlan]

    #
    # Est-ce un affichage de tous les vlans, ou d'un vlan en particulier ?
    #

    set nvlans [llength $lvlans]
    switch $nvlans {
	0 {
	    #
	    # Aucun vlan trouvé
	    #

	    set liste "Vlan '$qvlan' non trouvé sur les équipements"
	    ::webapp::send html [::webapp::file-subst $conf(pagen) \
						[list \
							[list %OBJETS% "Vlans"] \
							[list %LISTE%  $liste] \
							[list %EQ%     ""] \
							[list %VLAN%   $qvlan] \
							[list %ADDR%   ""] \
						    ] \
					    ]
	}
	1 {
	    #
	    # Récupérer le nom du vlan
	    #

	    set v [lindex $lvlans 0]
	    set desc "(pas de description)"
	    if {[info exists tabvlan($v)]} then {
		set desc $tabvlan($v)
	    }
	    set qvlan [::webapp::html-string $vlan]

	    #
	    # Récupérer les informations lues dans le graphe
	    #

	    set xl2 [format $conf(extractl2) $eq $iface $v]
	    set dot [generer-dot $format $eq $iface $v $xl2 $conf(urleq) nnodes]
	    if {[string equal $dot ""]} then {
		set liste "Vlan '$qvlan' non trouvé sur les équipements"
		::webapp::send html [::webapp::file-subst $conf(pagen) \
						    [list \
							    [list %OBJETS% "Vlans"] \
							    [list %LISTE%  $liste] \
							    [list %EQ%     ""] \
							    [list %VLAN%   $qvlan] \
							    [list %ADDR%   ""] \
							] \
						]
	    } else {
		set fd [open "$tmp.dot" "w"]
		puts $fd $dot
		close $fd

		#
		# Sélectionner le générateur de graphe
		#

		if {$nnodes > $conf(maxdot)} then {
		    set prog "$conf(neato) -Gmaxiter=10000"
		} else {
		    set prog "$conf(dot)"
		}

		set url "eq=$eq&iface=$iface&vlan=$v"

		#
		# Sélectionner le format et sortir la page
		#

		switch -- $format {
		    pdf {
			set fd [open "|$prog -Tps $tmp.dot | $conf(ps2pdf) - -" "r"]
			fconfigure $fd -translation binary
			set pdf [read $fd]
			close $fd
			::webapp::send rawpdf $pdf
		    }
		    png {
			set fd [open "| $prog -Tpng $tmp.dot 2>/dev/null" "r"]
			fconfigure $fd -translation binary
			set img [read $fd]
			close $fd
			::webapp::send png $img
			exit 0
		    }
		    default {
			set map [exec sh -c "$prog -Tcmapx < $tmp.dot"]
			::webapp::send html [::webapp::file-subst $conf(page1) \
						    [list \
							    [list %DESC%  $desc] \
							    [list %URL%   $url] \
							    [list %MAP%   $map] \
							    [list %EQ%    ""] \
							    [list %VLAN%  $qvlan] \
							    [list %ADDR%  ""] \
							] \
						]
		    }
		}

		file delete -force -- $tmp.dot
	    }
	}
	default {
	    #
	    # Afficher la liste (celle qui nous est retournée par
	    # chercher-vlans est déjà triée)
	    #

	    set liste "<UL>\n"
	    foreach id $lvlans {
		set desc [::webapp::html-string $tabvlan($id)]
		set url [format $conf(urll2) $id]
		append liste [format "<LI><A HREF=\"%s\">$id ($desc)</A>\n" $url]
	    }
	    append liste "</UL>"

	    #
	    # Sortie de la page
	    #

	    ::webapp::send html [::webapp::file-subst $conf(pagen) \
						[list \
							[list %OBJETS% "Vlans"] \
							[list %LISTE%  $liste] \
							[list %EQ%     ""] \
							[list %VLAN%   $qvlan] \
							[list %ADDR%   ""] \
						    ] \
					    ]

	}
    }

    #
    # Déconnexion de la base
    #

    fermer-base $dbfd
}

::webapp::cgi-exec main %DEBUG%
